#!/usr/bin/env node

/**
 * This is a template MCP server that implements a simple notes system.
 * It demonstrates core MCP concepts like resources and tools by allowing:
 * - Listing notes as resources
 * - Reading individual notes
 * - Creating new notes via a tool
 * - Summarizing all notes via a prompt
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListResourcesRequestSchema,
  ListToolsRequestSchema,
  ReadResourceRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

/**
 * Factory to create a configured WishForge MCP Server instance.
 * Each call creates fresh in-memory state for resources.
 */
export function createWishForgeServer(): Server {
  type Note = { title: string, content: string };
  const notes: { [id: string]: Note } = {
    "1": { title: "First Note", content: "This is note 1" },
    "2": { title: "Second Note", content: "This is note 2" }
  };

  const server = new Server(
    {
      name: "WishForge MCP",
      version: "0.1.0",
    },
    {
      capabilities: {
        resources: {},
        tools: {},
        prompts: {},
      },
    }
  );

  // List resources
  server.setRequestHandler(ListResourcesRequestSchema, async () => {
    return {
      resources: Object.entries(notes).map(([id, note]) => ({
        uri: `note:///${id}`,
        mimeType: "text/plain",
        name: note.title,
        description: `A text note: ${note.title}`
      }))
    };
  });

  // Read resource
  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
    const url = new URL(request.params.uri);
    const id = url.pathname.replace(/^\//, '');
    const note = notes[id];

    if (!note) {
      throw new Error(`Note ${id} not found`);
    }

    return {
      contents: [{
        uri: request.params.uri,
        mimeType: "text/plain",
        text: note.content
      }]
    };
  });

  // Tools list
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
      tools: [
        {
          name: "validate",
          description: "Validate a bearer token and return the owner phone number as {country_code}{number} (e.g., 919876543210)",
          inputSchema: {
            type: "object",
            properties: {
              bearerToken: { type: "string", description: "Bearer token to validate" }
            },
            required: ["bearerToken"]
          }
        },
        {
          name: "create_note",
          description: "Create a new note",
          inputSchema: {
            type: "object",
            properties: {
              title: { type: "string", description: "Title of the note" },
              content: { type: "string", description: "Text content of the note" }
            },
            required: ["title", "content"]
          }
        },
        {
          name: "wishify",
          description: "Generate short, highly-shareable wishes in Indic languages (multiple variants)",
          inputSchema: {
            type: "object",
            properties: {
              occasion: { type: "string", description: "e.g. Birthday, Diwali, Holi, Anniversary" },
              language: { type: "string", description: "e.g. Hinglish, Hindi, Marathi, Gujarati, Tamil", default: "Hinglish" },
              tone: { type: "string", description: "sweet | funny | formal", default: "sweet" },
              name: { type: "string", description: "Recipient name to personalize", default: "" },
              variantCount: { type: "number", description: "Number of variants (1-5)", default: 3 },
              emojiLevel: { type: "number", description: "0=no emoji, 1=some, 2=lots", default: 1 },
              length: { type: "string", description: "short | medium", default: "short" }
            },
            required: ["occasion"]
          }
        },
        {
          name: "shayari",
          description: "Generate 2-4 line rhyming shayari with optional transliteration",
          inputSchema: {
            type: "object",
            properties: {
              theme: { type: "string", description: "e.g. pyaar, dosti, motivation" },
              language: { type: "string", description: "Hindi | Urdu | Punjabi | Hinglish", default: "Hindi" },
              variantCount: { type: "number", description: "Number of variants (1-3)", default: 2 },
              script: { type: "string", description: "devanagari | latin (latin gives Hinglish)", default: "devanagari" }
            },
            required: ["theme"]
          }
        },
        {
          name: "status_pack",
          description: "Generate a pack of crisp WhatsApp Status lines for a theme (high-CTR hooks)",
          inputSchema: {
            type: "object",
            properties: {
              theme: { type: "string", description: "e.g. Monday motivation, exam prep, cricket win" },
              language: { type: "string", description: "Hinglish | Hindi | Marathi", default: "Hinglish" },
              count: { type: "number", description: "How many lines (3-7)", default: 5 },
              style: { type: "string", description: "clean | emoji-heavy | hashtaggy", default: "emoji-heavy" }
            },
            required: ["theme"]
          }
        }
      ]
    };
  });

  // Helpers
  const pickEmojis = (level: number, base: string[]) => level <= 0 ? [] : (level === 1 ? base.slice(0, 2) : base);
  const join = (parts: string[]) => parts.filter(Boolean).join(" ");
  const latin = (s: string) => s
    .replaceAll("‡§¶‡§ø‡§≤", "dil").replaceAll("‡§∞‡§æ‡§§", "raat").replaceAll("‡§¶‡•Å‡§Ü‡§è‡§Å", "duaayein")
    .replaceAll("‡§ñ‡•Å‡§∂", "khush").replaceAll("‡§§‡•á‡§∞‡•Ä", "teri").replaceAll("‡§Ø‡§æ‡§¶‡•á‡§Ç", "yaadein");

  // Tools handlers
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    switch (request.params.name) {
      case "validate": {
        const bearerToken = String(request.params.arguments?.bearerToken || "").trim();
        if (!bearerToken) {
          throw new Error("bearerToken is required");
        }
        const phoneNumber = process.env.OWNER_PHONE || "919998881729";
        return { content: [{ type: "text", text: phoneNumber }] };
      }

      case "create_note": {
        const title = String(request.params.arguments?.title);
        const content = String(request.params.arguments?.content);
        if (!title || !content) {
          throw new Error("Title and content are required");
        }
        const id = String(Object.keys(notes).length + 1);
        notes[id] = { title, content };
        return { content: [{ type: "text", text: `Created note ${id}: ${title}` }] };
      }

      case "wishify": {
        const occasion = String(request.params.arguments?.occasion || "").trim();
        const language = String(request.params.arguments?.language || "Hinglish");
        const tone = String(request.params.arguments?.tone || "sweet");
        const name = String(request.params.arguments?.name || "").trim();
        const variantCount = Math.max(1, Math.min(5, Number(request.params.arguments?.variantCount ?? 3)));
        const emojiLevel = Math.max(0, Math.min(2, Number(request.params.arguments?.emojiLevel ?? 1)));
        const length = String(request.params.arguments?.length || "short");
        if (!occasion) throw new Error("occasion is required");

        const baseEmojis = ["üéâ", "‚ú®", "üéä", "üåü", "üí´"]; // picked for celebration
        const em = pickEmojis(emojiLevel, baseEmojis);
        const personal = name ? `${name}, ` : "";

        const hooks: Record<string, string[]> = {
          Hinglish: [
            "Bas khushiyan hi khushiyan!",
            "Aaj ka din full vibe!",
            "Dil se blessings!"
          ],
          Hindi: [
            "‡§∏‡§¶‡§æ ‡§Æ‡•Å‡§∏‡•ç‡§ï‡•Å‡§∞‡§æ‡§§‡•á ‡§∞‡§π‡•ã!",
            "‡§ñ‡•Å‡§∂‡§ø‡§Ø‡§æ‡§Å ‡§Ü‡§™‡§ï‡•á ‡§ï‡§¶‡§Æ ‡§ö‡•Ç‡§Æ‡•á‡§Ç!",
            "‡§¢‡•á‡§∞‡•ã‡§Ç ‡§∂‡•Å‡§≠‡§ï‡§æ‡§Æ‡§®‡§æ‡§è‡§Å!"
          ]
        };
        const endings = hooks[language as keyof typeof hooks] || hooks.Hinglish;

        const mk = (i: number) => {
          const end = endings[i % endings.length];
          const shortCore = language === "Hinglish"
            ? `${personal}${occasion} mubarak ho!`
            : `${personal}${occasion} ‡§ï‡•Ä ‡§π‡§æ‡§∞‡•ç‡§¶‡§ø‡§ï ‡§∂‡•Å‡§≠‡§ï‡§æ‡§Æ‡§®‡§æ‡§è‡§Å!`;
          const mediumCore = language === "Hinglish"
            ? `${personal}${occasion} ke din, khushiyon ki barsaat ho!`
            : `${personal}${occasion} ‡§™‡§∞ ‡§ñ‡•Å‡§∂‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•Ä ‡§¨‡§∞‡§∏‡§æ‡§§ ‡§π‡•ã!`;
          const core = length === "short" ? shortCore : mediumCore;
          const toneTag = tone === "funny" ? (language === "Hinglish" ? "Thoda masti, thoda pyaar!" : "‡§•‡•ã‡§°‡§º‡•Ä ‡§Æ‡§∏‡•ç‡§§‡•Ä, ‡§•‡•ã‡§°‡§º‡§æ ‡§™‡•ç‡§Ø‡§æ‡§∞!")
            : tone === "formal" ? (language === "Hinglish" ? "Best wishes and regards." : "‡§∂‡•Å‡§≠‡§ï‡§æ‡§Æ‡§®‡§æ‡§è‡§Å ‡§è‡§µ‡§Ç ‡§∏‡§æ‡§¶‡§∞‡•§")
            : (language === "Hinglish" ? "Dil se blessings!" : "‡§¶‡§ø‡§≤ ‡§∏‡•á ‡§¶‡•Å‡§Ü‡§è‡§Å!");
          return join([core, end, toneTag, em.join(" ")]);
        };

        const variants: string[] = [];
        for (let i = 0; i < variantCount; i++) variants.push(mk(i));
        const text = variants.map((v, i) => `${i + 1}. ${v}`).join("\n");
        return { content: [{ type: "text", text }] };
      }

      case "shayari": {
        const theme = String(request.params.arguments?.theme || "").trim();
        const language = String(request.params.arguments?.language || "Hindi");
        const variantCount = Math.max(1, Math.min(3, Number(request.params.arguments?.variantCount ?? 2)));
        const script = String(request.params.arguments?.script || "devanagari");
        if (!theme) throw new Error("theme is required");

        const makeOne = (i: number) => {
          const lines = [
            `‡§¶‡§ø‡§≤ ‡§ï‡•Ä ‡§∞‡§æ‡§π‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§§‡•á‡§∞‡•Ä ‡§Ø‡§æ‡§¶‡•á‡§Ç ‡§¨‡§∏‡•Ä ‡§π‡•à‡§Ç`,
            `${theme} ‡§ï‡•Ä ‡§¨‡§æ‡§§‡•á‡§Ç ‡§á‡§® ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§π‡§Å‡§∏‡•Ä ‡§π‡•à‡§Ç‡•§`,
            `‡§ö‡§æ‡§Å‡§¶‡§®‡•Ä ‡§∞‡§æ‡§§ ‡§Æ‡•á‡§Ç ‡§¶‡•Å‡§Ü‡§è‡§Å ‡§Ø‡•á ‡§ï‡§π‡•Ä ‡§π‡•à‡§Ç,`,
            `‡§ñ‡•Å‡§∂ ‡§∞‡§π‡•á ‡§§‡•Ç ‡§π‡§Æ‡•á‡§∂‡§æ, ‡§Ø‡§π‡•Ä ‡§Ö‡§∞‡§ú‡§º‡•Ç ‡§∞‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‚Ä¶`
          ];
          let text = lines.join("\n");
          if (language === "Hinglish" || script === "latin") text = latin(text);
          return text;
        };
        const out = Array.from({ length: variantCount }, (_, i) => `${i + 1}.\n${makeOne(i)}`).join("\n\n");
        return { content: [{ type: "text", text: out }] };
      }

      case "status_pack": {
        const theme = String(request.params.arguments?.theme || "").trim();
        const language = String(request.params.arguments?.language || "Hinglish");
        const count = Math.max(3, Math.min(7, Number(request.params.arguments?.count ?? 5)));
        const style = String(request.params.arguments?.style || "emoji-heavy");
        if (!theme) throw new Error("theme is required");

        const emojiSet = style === "emoji-heavy" ? ["üî•", "‚ú®", "üí™", "üöÄ", "üéØ", "‚ö°", "üèÜ"] : ["‚Ä¢"];
        const hook = (core: string, i: number) => `${emojiSet[i % emojiSet.length]} ${core}`;

        const cores: string[] = language === "Hinglish" ? [
          `${theme} mode: ON`,
          `Bas karte jao, baaki sab ho jayega`,
          `No excuses, only ${theme}`,
          `${theme} vibes only`,
          `Kal se nahi, aaj se ${theme}`,
          `Focus > Fomo ‚Äî ${theme}`,
          `Small steps, big ${theme}`,
        ] : [
          `${theme} ‡§Æ‡•ã‡§°: ‡§ö‡§æ‡§≤‡•Ç`,
          `‡§¨‡§∏ ‡§ï‡§∞‡§§‡•á ‡§ú‡§æ‡§ì, ‡§¨‡§æ‡§ï‡§º‡•Ä ‡§∏‡§¨ ‡§π‡•ã ‡§ú‡§æ‡§è‡§ó‡§æ`,
          `‡§¨‡§π‡§æ‡§®‡•á ‡§®‡§π‡•Ä‡§Ç, ‡§∏‡§ø‡§∞‡•ç‡§´‡§º ${theme}`,
          `${theme} ‡§ï‡•Ä ‡§µ‡§æ‡§á‡§¨‡•ç‡§∏ ‡§ì‡§®‡§≤‡•Ä`,
          `‡§ï‡§≤ ‡§®‡§π‡•Ä‡§Ç, ‡§Ü‡§ú ‡§∏‡•á ${theme}`,
          `‡§ß‡•ç‡§Ø‡§æ‡§® > ‡§≤‡§æ‡§≤‡§ö ‚Äî ${theme}`,
          `‡§õ‡•ã‡§ü‡•á ‡§ï‡§¶‡§Æ, ‡§¨‡§°‡§º‡§æ ${theme}`,
        ];
        const lines: string[] = [];
        for (let i = 0; i < count; i++) lines.push(hook(cores[i % cores.length], i));
        const text = lines.map((l, i) => `${i + 1}. ${l}`).join("\n");
        return { content: [{ type: "text", text }] };
      }

      default:
        throw new Error("Unknown tool");
    }
  });

  // Prompts
  server.setRequestHandler(ListPromptsRequestSchema, async () => {
    return {
      prompts: [
        { name: "summarize_notes", description: "Summarize all notes" }
      ]
    };
  });

  server.setRequestHandler(GetPromptRequestSchema, async (request) => {
    if (request.params.name !== "summarize_notes") {
      throw new Error("Unknown prompt");
    }

    const embeddedNotes = Object.entries(notes).map(([id, note]) => ({
      type: "resource" as const,
      resource: { uri: `note:///${id}`, mimeType: "text/plain", text: note.content }
    }));

    return {
      messages: [
        { role: "user", content: { type: "text", text: "Please summarize the following notes:" } },
        ...embeddedNotes.map(note => ({ role: "user" as const, content: note })),
        { role: "user", content: { type: "text", text: "Provide a concise summary of all the notes above." } }
      ]
    };
  });

  return server;
}

/**
 * Start the server using stdio transport when explicitly requested.
 */
async function main() {
  const server = createWishForgeServer();
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

if (process.env.MCP_STDIO === "1") {
  main().catch((error) => {
    console.error("Server error:", error);
    process.exit(1);
  });
}
